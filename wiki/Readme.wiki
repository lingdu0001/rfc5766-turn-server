#labels Featured,Version-2.6.1.1
TURN(08 Aug 2013)	

== GENERAL INFORMATION ==

       The  *TURN Server* project contains the source code of a TURN server and
       TURN client messaging library. Also, some extra programs	provided,  for
       testing-only purposes.

       See the INSTALL file for	the building instructions.

       After the build,	you will have the following binary images:

 *     _*turnserver*_:  *TURN Server* relay. The compiled binary image of this program is located in bin/ sub-directory.
 *     _*turnadmin*_: TURN administration tool. This tool can be used for:
   # generation	of TURN keys for the user accounts. For security reasons, we do not recommend storing passwords openly. The better	option is to use pre-processed "keys" which are then used for authentication. These keys are generated by _turnadmin_.
   # listing available users in flat file, or in databases.
   # adding and deleting users in the flat file or in the databases.
   # updating user passwords. 
   # setting shared secret for TURN REST API.
 *     _*turnutils_uclient*_: emulates multiple UDP,TCP,TLS or DTLS  clients. The compiled binary image of this program is located in bin/ sub-directory.
{{{
       WARNING:	the turnutils_uclient program is a primitive client application and 
       is provided for test-only purposes.  
       It does not implement the re-transmission pattern that is necessary for a
       correct	TURN client implementation. In TURN, the retransmission	burden
       is lying	almost entirely on the	client application. We provide	the  messaging
       functionality  in the client library, but the client must implement the
       correct Networking IO processing	in the client program code.
}}}
 *	_*turnutils_peer*_: a simple stateless UDP-only "echo" server, to be used as the final server in relay pattern ("_peer_"). For every incoming UDP packet, it simply echoes it back.  (this program is provided for the testing purposes only !)	When the test clients are communicating in the	client-to-client manner, this component	is not needed. The compiled binary image of this program is located in bin/ subdirectory.
 *	_*turnutils_stunclient*_: a simple STUN	client example that implements RFC 5389 and RFC 5780.	 The  compiled	binary image of this program is located in bin/ subdirectory.
 *	_*turnutils_rfc5769check*_: a utility that checks the correctness of the STUN/TURN protocol implementation. This program will perform several checks and print the result on the screen. It will exit with 0 status if everything is OK, and with (-1) if there was an error in the protocol implementation.   

       In the "examples/scripts"	subdirectory, you will find the	 examples  of  command
       lines to	be used	to run the programs. The scripts are meant to be run from examples/ subdirectory, for example:
{{{
	$ cd examples
	$ ./scripts/longtermsecure/secure_relay.sh
}}}

== RUN ==

===turnserver application: a TURN relay server implementation===

====Usage:====
{{{
       $ turnserver [flags] [-n | -c <config-file>] [ --userdb=<userdb-file> | --psql-userdb=<db-conn-string> | --mysql-userdb=<db-conn-string> ] [options]
       $ turnserver -h
}}}

====Flags:====

   * *-v,* *--verbose* 'Moderate' verbose mode.
   * *-V,* *--Verbose* 'Extra' verbose mode, very annoying and not recommended.
   * *-o,* *--daemon* Run server process as daemon.
   * *-f,* *--fingerprint* Use fingerprints in the TURN messages. If an incoming request contains fingerprint, then TURN server will always add fingerprints to the messages in this session, regardless of the per-server setting.
   * *-a,* *--lt-cred-mech* Use long-term credentials mechanism (this one you need for WebRTC usage). This option can be used with either flat file user database or PostgreSQL or MySQL or Redis DB for user keys storage.
   * *-A,* *--st-cred-mech* Use short-term credentials mechanism. This option requires a PostgreSQL or MySQL or Redis DB for short term passwords storage.
   * *-z,* *--no-auth* Do not use any credentials mechanism, allow anonymous access. Opposite to *-a* and *-A* options.
   * *--use-auth-secret* Flag that sets a special WebRTC authorization option that is based upon authentication secret. This feature purpose is to support "TURN Server REST API" as described in TURNServerRESTAPI.pdf in the docs. This option can be used with long-term credentials mechanism only - it does not make much sense with the short-term mechanism. 
   * *--no-udp* Do not start 'plain' UDP listeners.
   * *--no-tcp* Do not start 'plain'TCP listeners.
   * *--no-tls* Do not start TLS listeners.
   * *--no-dtls* Do not start DTLS	listeners. This is recommended when you do not need DTLS. With this option, the plain UDP works faster.
   * *--no-udp-relay* Do not allow UDP relay endpoints defined in RFC 5766, use only TCP relay endpoints as defined in RFC 6062.
   * *--no-tcp-relay* Do not allow TCP relay endpoints defined in RFC 6062, use only UDP relay endpoints as defined in RFC 5766. 
   * *--stale-nonce* Use extra security with nonce value having limited lifetime (600 secs).
   * *--no-stdout-log* Flag to prevent stdout log messages. By default, all log messages are going to both stdout and to the configured log. With this option everything will be going to the configured log file only (unless the log file itself is stdout).
   * *--syslog* Flag to redirect everything into the system log (syslog).
   * *-S,* *--stun-only* Run as STUN server only, all TURN requests will be ignored.
   * *--no-loopback-peers* Disallow peers on the loopback addresses (127.x.x.x and ::1).
   * *--no-multicast-peers* Disallow peers on well-known broadcast addresses (224.0.0.0 and above, and {{{FFXX:*}}}).
   * * --udp-self-balance* balance the UDP traffic among the aux endpoints (for clients supporting 300 ALTERNATE-SERVER response). See *--aux-server* option.
   * *-h* Help.

====Config file setting:====

   * *-n* Do not use configuration file, use only command line parameters.
   * *-c* {{{<file-name>}}}     Configuration file name (default - turnserver.conf).  The	format of  config  file can be seen in the supplied examples/etc/turnserver.conf example file. Long names of the options are used as the configuration  items names in the file. If not an absolute path is supplied, then the file is searched in the following	directories:
	      *	 current directory
	      *	 current directory etc/	subdirectory
	      *	 upper directory level etc/
	      *	 /etc/
	      *	 /usr/local/etc/
	      
====User database settings:====

   * *-b,* *--userdb* {{{<file-name>}}}
	      'Dynamic'	user database file name	(default  -  turnuserdb.conf),
			for long-term credentials mechanism only.
	      This  user  database  is	being  dynamically  checked  while the
	      _turnserver_ is working, and the  user  accounts  can  be  changed
	      dynamically by editing the file.
   * *-e,* *--psql-userdb,* *--sql-userdb* {{{<connection-string>}}}
   		  User database connection string for PostgreSQL. 
		This database can be used for long-term and short-term credentials mechanisms, and it can store the secret value for secret-based timed authentication in TURN RESP API. The connection string format is like that:
{{{
"host=<host> dbname=<dbname> user=<db-user> password=<db-user-password> connect_timeout=<seconds>"
}}}
(for 8.x or newer Postgres), or:
{{{
"postgresql://username:password@hostname:port/databasename"
}}}
 (for 9.x or newer Postgres). 
	See the INSTALL file for more explanations and examples.

		Also, see http://www.PostgreSQL.org for full PostgreSQL documentation.
   * *-M,* *--mysql-userdb* {{{<connection-string>}}}
   		  User database connection string for MySQL. 
		This database can be used for long-term and short-term credentials mechanisms, and it can store the secret value for secret-based timed authentication in TURN RESP API. The (proprietary) connection string format is like this:
		{{{
"host=<host> dbname=<dbname> user=<db-user> password=<db-user-password> connect_timeout=<seconds>".
}}}
		See the INSTALL file for more explanations and examples.
		
		Also, see http://www.mysql.org for full MySQL documentation.
		
   * *-N,* *--redis-userdb* {{{<connection-string>}}}
   		  User database connection string for Redis. 
		This database can be used for long-term and short-term credentials mechanisms, and it can store the secret value for secret-based timed authentication in TURN RESP API. The (proprietary) connection string format is like this:
		{{{
"ip=<ip-addr> dbname=<number> password=<db-password> connect_timeout=<seconds>".
}}}
		See the INSTALL file for more explanations and examples.
		
		Also, see http://redis.io for full Redis documentation. 

====Options:====

    *   *-d,* *--listening-device* {{{<device-name>}}} Listener interface device (optional functionality, Linux only). The turnserver process must have root privileges to bind the	listening endpoint to a device. If turnserver must run as a	process without root privileges, then just do not use this setting.
    *   *-L,* *--listening-ip* {{{<ip>}}} Listener IP address of relay server.  Multiple listeners can  be specified.  If no *IP*(s) specified, then all IPv4 and IPv6 system IPs will be used for listening.
    *   *-p,* *--listening-port* {{{<port>}}} TURN listener port for UDP and TCP listeners (Default: 3478). Note: actually, TLS & DTLS sessions can connect to the "plain" TCP & UDP port(s), too - if allowed by configuration. For example, the default listening port can be set to 80 or 443, to go around some strict NATs. Remember that ports < 1024 may require superuser privileges to start the turnserver process. 
    *   *--tls-listening-port* {{{<port>}}}   TURN listener port for TLS and DTLS listeners (Default: 5349). Note: actually, "plain" TCP & UDP sessions can connect to the TLS & DTLS port(s), too - if allowed by configuration. For example, the default tls listening port can be set to 443, to go around some strict NATs. Remember that ports < 1024 may require superuser privileges to start the turnserver process. For secure TCP connections, we currently support SSL version 3 and TLS versions 1.0, 1.1, 1.2. SSL2 "encapsulation mode" is also supported. For secure UDP connections, we support DTLS version 1.
    *   *--alt-listening-port* {{{<port>}}}   Alternative listener port for UDP and TCP listeners; default (or zero) value means "listening port plus one". This is needed for CHANGE_REQUEST attribute in STUN NAT behavior discovery functionality, like one defined in STUN RFC 3489 or in RFC 5780. The STUN/TURN Server supports CHANGE_REQUEST only if it is started with more than one listening IP address of the same family (IPv4 or IPv6). If only single IP address is used, then the CHANGE_REQUEST attribute in BINDING request will be rejected.
    *   *--alt-tls-listening-port* {{{<port>}}}   Alternative listener port for TLS and DTLS listeners; default (or zero) value means "TLS listening port plus one".
    *   *--aux-server* {{{<IPv4:port>|<[IPv6]:port>}}}	Auxiliary STUN/TURN server listening endpoint. Aux servers have almost full TURN and STUN functionality. The (minor) limitations are:
	# Auxiliary servers do not have alternative ports and they do not support STUN RFC 5780 functionality (CHANGE REQUEST).
	# Auxiliary servers also are never returning ALTERNATIVE-SERVER reply.			
Valid formats are 1.2.3.4:5555 for IPv4 and [1:2::3:4]:5555 for IPv6. There may be multiple aux-server options, each will be used for listening to client requests.
    *   *-i,* *--relay-device* {{{<device-name>}}} Relay interface device to be used for the relay sockets (optional, Linux	only).
    *   *-E,* *--relay-ip* {{{<ip>}}} Relay  address  (the local IP address that will be used to relay the packets to the _peer_).	Multiple relay addresses may be	 used. If  no  relay  *IP*(s) specified, then all non-loopback system IPs will be used.
    *   *-X,* *--external-ip* {{{<public-ip>[/private-ip]}}} TURN Server public/private address mapping, if the server is behind NAT. In that situation, if a -X is used in form {{{"-X <ip>"}}} then that ip will be reported as relay IP address of all allocations. This scenario works only in a simple case when one single relay address is be used, and no CHANGE_REQUEST STUN functionality is required. That single relay address must be mapped by NAT to the 'external' IP. The "external-ip" value, if not empty, is returned in XOR-RELAYED-ADDRESS field. For that 'external' IP, NAT must forward ports directly (relayed port 12345 must be always mapped to the same 'external' port 12345). In more complex case when more than one IP address is involved, that option must be used several times, each entry must have form {{{"-X <public-ip/private-ip>"}}}, to map all involved addresses. CHANGE_REQUEST NAT discovery STUN functionality will work correctly, if the addresses are mapped properly, even when the TURN server itself is behind A NAT. By default, this value is empty, and no address mapping is used.
    *   *-m,* *--relay-threads* {{{<number>}}} Number of non-UDP relay threads (for TCP/TLS/DTLS) to handle the established connections (in addition to authentication thread and the listener thread). If set to 0 then application handles that traffic in a single thread. The default thread number is the number of CPUs. "Pure" UDP traffic is handled in separate threads, the number of those threads is always equals to the number of the listening endpoints.
    *   *--min-port* {{{<port>}}} Lower bound of the UDP port range	for  relay  endpoints  allocation.  Default value is 49152, according to RFC 5766.
    *   *--max-port* {{{<port>}}} Upper  bound  of	the UDP	port range for relay endpoints allocation.  Default value is 65535, according to RFC 5766.
    *   *-u,* *--user* {{{<user:password> or <user:0xkey>}}} Long-term credentials user account, in the column-separated form 'username:key'. Multiple user accounts can be used in the command line. The key is either the	user password, or the key is generated by _turnadmin_ command. In the second case, the key  must be  prepended with  '0x'  symbols. The key is calculated over the user name, the realm, and the user password. So, if the realm has been changed, then all user keys in the database have to be re-set.
    *   *-r,* *--realm* {{{<realm>}}} Realm to be used for all users, with long term credentials only.
    *   *-q,* *--user-quota* {{{<number>}}} Per-user allocation quota: how many concurrent allocations a user can create.
    *   *-Q,* *--total-quota* {{{<number>}}} Total allocations quota: global limit on concurrent allocations.
    *   *--static-auth-secret* {{{<secret>}}} Static authentication secret value (a string). If not set, then the turn server will try to use the 'dynamic' value in turn_secret table in user database (if present). The database-stored value can be changed on-the-fly by a separate program, so this is why that other mode is 'dynamic'. Multiple shared secrets can be used (both in the database and in the "static" fashion).
    *	*-s,* *--max-bps* {{{<number>}}} Max bytes-per-second bandwidth a TURN session is allowed to handle (input and output network streams combined). Anything above that limit will be dropped.
    *   *--cert* {{{<file-name>}}} Certificate file, PEM format. Same file search rules applied  as for the configuration file. If both *--no-tls* and *--no-dtls* options are specified, then this parameter is not needed. Default value is turn_server_cert.pem.
    *   *--pkey* {{{<file-name>}}} Private key file, PEM format. Same file search rules applied as for the configuration file. If both *--no-tls* and *--no-dtls* options are specified, then this parameter is not needed. Default value is turn_server_pkey.pem.
    *   *-l*, *--log-file* {{{<file-name> or "stdout" or "syslog"}}} Option to set the full path name of the log file. By default, the turnserver tries to open a log file in  /var/log, /var/tmp, /tmp and current directories directories (which open operation succeeds first that file will be used). With this option you can set the definite log file name. The special names are "stdout" and "-" - they will force everything to the stdout. Also, the file name "syslog" will redirect everything into the system log (syslog) as if the option --syslog was set.
    *   *--alternate-server* {{{<ip:port>}}} Option to set the "redirection" mode. The value of this option will be the address of the alternate server for UDP & TCP service in form of  {{{<ip>[:<port>]}}}. The server will send this value in the attribute ALTERNATE-SERVER, with error 300, on ALLOCATE request, to the client. Client will receive only values with the same address family as the client network endpoint address family. See RFC 5389 and RFC 5766 for ALTERNATE-SERVER functionality description. The client must use the obtained IP value for subsequent TURN communications. If more than one --alternate-server options are provided, then the functionality can be more accurately described as "load-balancing" than a mere "redirection". If the port number is omitted, then the default port number 3478 for the UDP/TCP protocols will be used. Colon (:) characters in IPv6 addresses may conflict with the syntax of the option. To alleviate this conflict, literal IPv6 addresses are enclosed in square brackets in such resource identifiers, for example: [2001:db8:85a3:8d3:1319:8a2e:370:7348]:3478 . Multiple alternate servers can be set. They will be used in the round-robin manner. All servers in the pool are considered of equal weight and the load will be distributed equally. For example, if we have 4 alternate servers, then each server will receive 25% of ALLOCATE requests. A alternate TURN server address can be used more than one time with the alternate-server option, so this can emulate "weighting" of the servers.
    *   *--tls-alternate-server* {{{<ip:port>}}}	Option to set alternative server for TLS & DTLS services in form of {{{<ip>[:<port>]}}}. If the port number is omitted, then the default port number 5349 for the TLS/DTLS protocols will be used. See the previous option for the functionality description.
    *   *-C*, *--rest-api-separator* {{{<symbol>}}}	This is the username/timestamp separator symbol (character) in TURN REST API. The default value is colon (':').
    *   *-O*, *--redis-statsdb*	{{{<connection-string>}}}	Redis status and statistics database connection string, if used (default - empty, no Redis stats DB used). This database keeps allocations status information, and it can be also used for publishing and delivering traffic and allocation event notifications. The connection string has the same parameters as redis-userdb connection string.
    *   *--max-allocate-timeout* {{{<seconds>}}}	Max time, in seconds, allowed for full allocation establishment. Default is 60 seconds.
    *   *--denied-peer-ip=*{{{<IPaddr[-IPaddr]>}}}, *--allowed-peer-ip=*{{{<IPaddr[-IPaddr]>}}} Options to ban or allow specific ip addresses or ranges of ip addresses. If an ip address is specified as both allowed and denied, then the ip address is considered to be allowed. This is useful when you wish to ban a range of ip addresses, except for a few specific ips within that range.	This can be used when you do not want users of the turn server to be able to access machines reachable by the turn server, but would otherwise be unreachable from the internet (e.g. when the turn server is sitting behind a NAT).
    *   *--cipher-list*	Allowed OpenSSL cipher list for TLS/DTLS connections. Default value is "ALL:eNULL:aNULL:NULL".
    
==== LOAD BALANCE ====

To set a load balancing scheme, you have three options:

	# Set a complex networking load-balancing equipment that redirects the requests to a member of the TURN servers group. It must take care about redirecting the requests to the same server from the same client - because some TURN sessions from the same client must share the information.
	# Set a less complex scheme with round-robin DNS. The same precaution must be taken as in the first case.
	# Use build-in balancing capability with ALTERNATE-SERVER option (--alternate-server and --tls-alternate-server options). In this case, the shared information in the session will be taken care of automatically by the "master" TURN server.
	
==== WEBRTC USAGE ====

This is a set of notes for the WebRTC users:

  # WebRTC uses long-term credentials mechanism, so you have to use -a option (or --lt-cred-mech). WebRTC relaying will not work with anonymous access or with short-term credentials. With -a option, do not forget to set the realm (-r option). You will also have to set up the user accounts, for that you have a number of options (see also the DATABASES section below):
    *   command-line options (-u).
    *   userdb config file.
    *   database table (if PostgreSQL or MySQL used). You will have to set keys with turnadmin utility (see docs and wiki for turnadmin). You cannot use open passwords in the database. 
    *   Redis key/value pair(s), if Redis is used. You key use either keys or open passwords with Redis; see turndb/testredisdbsetup.sh file.
    *   you also can use the TURN REST API (see docs). You will need shared secret(s) set either	through the command line option, or through the config file, or through the database table (PostgreSQL or MySQL), or through the Redis database.
  # Usually WebRTC uses fingerprinting (-f).
  # -v option may be nice to see the connected clients.
  # -X is needed if you are running your TURN server behind a NAT.
  # --min-port and --max-port may be needed if you want to limit the relay endpoints ports number range.

==== TURN REST API ====

In WebRTC, the browser obtains the TURN connection information from the web
server. This information is a secure information - because it contains the 
necessary TURN credentials. As these credentials are transmitted over the 
public networks, we have a potential security breach.

If we have to transmit a valuable information over the public network, 
then this information has to have a limited lifetime. Then the guy who 
obtains this information without permission will be able to perform 
only limited damage.

This is how the idea of TURN REST API - time-limited TURN credentials - 
appeared. This security mechanism is based upon the long-term credentials 
mechanism. The main idea of the REST API is that the web server provides 
the credentials to the client, but those credentials can be used only 
limited time by an application that has to create a TURN server connection.

The "classic" long-term credentials mechanism (LTCM) is described here:

http://tools.ietf.org/html/rfc5389#section-10.2

http://tools.ietf.org/html/rfc5389#section-15.4

For authentication, each user must know two things: the username and the 
password. The nonce and the realm values are supplied by the TURN server. 
But LTCM is not saying anything about the nature and about the persistence 
of the username and of the password; and this is used by the REST API.

In the TURN REST API, there is no persistent passwords for users. A user has 
just the username. The password is always temporary, and it is generated by 
the web server on-demand, when the user accesses the WebRTC page. And, 
actually, a temporary one-time session only, username is provided to the user, 
too. 

The temporary user is generated as:

{{{temporary-username="username" + ":" + "timestamp"}}}

where username is the persistent user name, and the timestamp format is just 
seconds sinse 1970 - the same value as time(NULL) function returns. The timestamp is the expiration time of the temporary password.

The temporary password is obtained as HMAC-SHA1 function over the temporary
username, with shared secret as the HMAC key, and then the result is encoded:

{{{temporary-password = base64_encode(hmac-sha1(shared-secret, temporary-username))}}}

Both the TURN server and the web server know the same shared secret. How the
shared secret is distributed among the involved entities is left to the WebRTC
deployment details - this is beyond the scope of the TURN REST API.

So, a timestamp is used for the temporary password calculation, and this 
timestamp can be retrieved from the temporary username. This information
is valuable, but only temporary, while the timestamp is not expired. Without
knowledge of the shared secret, a new temporary password cannot be generated.

This is all formally described in Justin Uberti TURN REST API draft specs document that can be obtained here: [http://tools.ietf.org/html/draft-uberti-behave-turn-rest-00 TURN REST API BEHAVE DRAFT SPECS] 

Once the temporary username and password are obtained by the client (browser)
application, then the rest is just 'classic" long-term credentials mechanism.
For developers, we are going to describe it step-by-step below:

  # a new TURN client sends a request command to the TURN server.
  # TURN server sees that this is a new client and the message is not authenticated.
  # the TURN server generates a random nonce string, and return the error 401 to the client, with nonce and realm included.
  # the client sees the 401 error and it extracts two values from the error response: the nonce and the realm.
  # the client uses username, realm and password to produce a key: {{{  key = MD5(username ":" realm ":" SASLprep(password)) }}} (SASLprep is described here: http://tools.ietf.org/html/rfc4013)
  # the client forms a new request, adds username, realm and nonce to the request. Then, the client calculates and adds the integrity field to the request. This is the trickiest part of the process, and it is described in the end of section 15.4: http://tools.ietf.org/html/rfc5389#section-15.4
  # the client, optionally, adds the fingerprint field. This may be also a tricky procedure, described in section 15.5 of the same document. WebRTC usually uses fingerprinted TURN messages.
  # the TURN server receives the request, reads the username.
  # then the TURN server checks that the nonce and the realm in the request are the valid ones.
  # then the TURN server calculates the key.
  # then the TURN server calculates the integrity field.
  # then the TURN server compares the calculated integrity field with the received one - they must be the same. If the integrity fields differ, then the request is rejected.

In subsequent communications, the client may go with exactly the same 
sequence, but for optimization usually the client, having already 
information about realm and nonce, pre-calculates the integrity string 
for each request, so that the 401 error response becomes unnecessary. 
The TURN server may use "--stale-nonce" option for extra security: in 
some time, the nonce expires and the client will obtain 438 error response
with the new nonce, and the client will have to start using the new nonce.

In subsequent communications, the sever and the client will always assume 
the same password - the original password becomes the session parameter and 
is never expiring. So the password is not changing while the session is valid
and unexpired. So, if the session is properly maintained, it may go forever, 
even if the user password has been already changed (in the database). The 
session simply is using the old password. Once the session got disconnected, 
the client will have to use the new password to re-connect (if the password 
has been changed).

An example when a new shared secret is generated every hour by the TURN server
box and then supplied to the web server, remotely, is provided in the script {{{examples/scripts/restapi/shared_secret_maintainer.pl}}} .

A very important thing is that the nonce must be totally random and it must be 
different for different clients and different sessions.

==== DATABASES ====

For the user database, the turnserver has the following options:

  # Users can be set in the command line, with multiple -u or --user options. Obviously, only a few users can be set that way, and their credentials are fixed for the turnserver process lifetime.
  # Users can be set in turnusers.conf flat file DB. The turnserver process periodically re-reads this file, so the user accounts may be changed while the turnserver is running. But still a relatively small (up to a hundred ?) number of users can be handled that way.
  # Users can be stored in PostgreSQL database, if the turnserver was compiled with PostgreSQL support. Each time turnserver checks user credentials, it reads the database (asynchronously, of course, so that the current flow of packets is not delayed in any way), so any change in the database content is immediately visible by the turnserver. This is the way if you need the best scalability. The schema for the database can be found in schema.sql file. For long-term credentials, you have to set the "keys" for the users; the "keys" are generated by the turnadmin utility. For the key generation, you need username, password and the realm. All users in the database must use the same realm value; if down the road you will decide to change the realm name, then you will have to re-generate all user keys (that can be done in a batch script). If you are using short-term credentials, then you use open passwords in the database; you will have to make sure that nobody can access the database outside of the TURN server box.
  # The same as previous is true for MySQL database. The same schema file is applicable. The same considerations are applicable.
  # The same is true for the Redis database, but the Redis database has a different schema - it can be found (in the form of explanation) in schema.userdb.redis. Also, in Redis you can store both "keys" and open passwords (for long term credentials) - the "open password" option is less secure but more convenient for low-security environments. For short-term credentials, you will use open passwords only. See the file turndb/testredisdbsetup.sh as an example. 
  # Of course, the turnserver can be used in non-secure mode, when users are allowed to establish sessions anonymously. Then you do not need a database at all. But in most cases (like WebRTC) that will not work.

For the status and statistics database, there are two choices:

  # The simplest choice is not to use it. Do not set --redis-statsdb option, and this functionality will be simply ignored.
  # If you choose to use the statistics database, then set the --redis-statsdb option. This may be the same database as in --redis-userdb option, or it may be a different database. You may want to use different database for security or convenience reasons. Also, you can use different database management systems for the user database and for the status and statistics database. For example, you can use MySQL as the user database, and you can use Redis for the statistics. Or you can use Redis for both.

So, we have 6 choices for the user management, and 2 choices for the statistics management. These two are totally independent. So, you have overall 6*2=12 ways to handle persistent information, choose any for your convenience.

You do not have to handle the database information "manually" - the turnadmin program can handle everything for you. For PostgreSQL and MySQL you will just have to create an empty database with schema.sql SQL script. With Redis, you do not have to do even that - just run turnadmin and it will set the users for you (see the turnadmin manuals).

=== turnadmin application: a TURN relay administration tool===

====Usage:====
{{{
       $ turnadmin [command] [options]
       $ turnadmin [ -h	| --help]
}}}
====Commands:====

 * *-k,* *--key* Generate key for a long-term credentials mechanism user.
 * *-a,* *--add* Add or update a long-term user.
 * *-A,* *--add-st* Add or update a short-term credentials mechanism user.
 * *-d,* *--delete* Delete a long-term user.
 * *-D,* *--delete-st* Delete a short-term user.
 * *-l,* *--list* List all long-term users.
 * *-L,* *--list-st* List all short-term users.
 * *-s,* *--set-secret=...* Set secret in the database.
 * *-S,* *--show-secret* Show secret stored in database.
 * *-X,* *--delete-secret* {{{<secret>}}}	Delete a shared secret.
 * *--delete-all-secrets*	Delete all shared secrets for REST API.

 ====Options:====

 * *-b,* *--userdb* {{{<file-name>}}} 'Dynamic' user database file name (default - turnuserdb.conf).
 * *-e,* *--psql-userdb,* *--sql-userdb* {{{<connection-string>}}} PostgreSQL database connection string.
 * *-M,* *--mysql-userdb* {{{<connection-string>}}} MySQL database connection string.
 * *-N,* *--redis-userdb* {{{<connection-string>}}} Redis database connection string.
 * *-u,* *--user* {{{<user>}}}   User name.
 * *-r,* *--realm* {{{<realm>}}}    Realm.
 * *-p,* *--password* {{{<password>}}} Password.
 * *-h,* *--help* Help.

====Generate a key:====
{{{
       $ turnadmin -k -u <username> -r <realm> -p <password>
}}}
====Add/update a user (and realm) in the userdb file:====
{{{
       $ turnadmin -a [-b <userdb-file> | -e <db-connection-string> | -M <db-connection-string>  | -N <db-connection-string> ] -u <username>	-r <realm>  -p	<password>
}}}
====Delete a user from the userdb file:====
{{{
       $ turnadmin -d [-b <userdb-file> | -e <db-connection-string> | -M <db-connection-string>  | -N <db-connection-string> ] -u <username>
}}}
====List all long-term users in MySQL database:====
{{{
$ turnadmin -l --mysql-userdb="<db-connection-string>"
}}}
====List all short-term users in PostgreSQL database:====
{{{
$ turnadmin -L --psql-userdb="<db-connection-string>"
}}}
====List all long-term users in Redis database:====
{{{
$ turnadmin -l --redis-userdb="<db-connection-string>"
}}}
====Set secret:====
{{{
$ turnadmin -s <secret> --mysql-userdb="<db-connection-string>"
}}}
====Show secret(s):=====
{{{
$ turnadmin -S --psql-userdb="<db-connection-string>"
}}}
====Show secret(s):=====
{{{
$ turnadmin -S --redis-userdb="<db-connection-string>"
}}}

====Help:====
{{{
       $ turnadmin -h
}}}

=== turnutils_uclient application (for test purposes only)===
  It was designed to simulate multiple clients. It uses asynch IO API in  libevent to  handle  multiple  clients. A  client connects to the relay, negotiates the session, and sends	multiple  (configured  number) messages	to  the	 server	 (relay), expecting the	same number of replies. The length of the messages is configurable.   The  message is an arbitrary octet stream, but it	can be configured as a string.  The number of the messages to send is configurable.

====Usage:====
{{{
       $ turnutils_uclient [-tSvsyhcxg] [options]	<TURN-Server-IP-address>
}}}
====Flags:====

 *      *-t*     Use TCP for communications between client and TURN server (default is UDP).
 *      *-T*     Use TCP for the relay transport (default - UDP). Implies options -t, -y, -c, and ignores options -s, -e, -r and -g.
 *      *-P*     Passive TCP (RFC6062 with active peer). Implies -T.
 *      *-S*     Secure connection: TLS for TCP, DTLS for UDP.
 *      *-U*     Secure unencrypted connection (suite eNULL): SSL/TLS for TCP, DTLS for UDP.
 *      *-v*     Verbose.
 *      *-s*     Use "Send" method	in TURN; by default, it	uses TURN Channels.
 *      *-y*     Use  client-to-client  connections: RTP/RTCP pair	of channels to another RTP/RTCP pair of channels.  with this  option  the  _turnutils_peer_ application  is  not used, as the allocated relay endpoints	are talking to each other.
 *      *-h*     Hang on indefinitely after the last sent packet.
 *      *-c*     Do not create rtcp connections.
 *      *-x*     Request IPv6 relayed address (RFC6156).
 *      *-g*     Set DONT_FRAGMENT	parameter in TURN requests.
 *      *-A*     Use short-term credentials mechanism for authentication. By default, the program uses the long-term credentials mechanism if authentication is required.
 *      *-D*     Mandatory channels padding (like in *pjnath*).
 *      *-N*     Negative tests (some limited cases only).
 *      *-O*     "DOS attack" intense mode.

====Options:====

 *      *-l* {{{<number>}}}     Message length (Default: 100 Bytes).
 *      *-i* {{{<file-name>}}}     Certificate file (for secure connections only).
 *      *-k* {{{<file-name>}}}     Private key file (for secure connections only).
 *      *-p* {{{<port>}}}     *TURN* *Server* port (Default: 3478 unsecure,	5349 secure).
 *      *-n* {{{<number>}}}     Number of	messages to send (Default: 5).
 *      *-d* {{{<device-name>}}}     Local interface device (optional, Linux only).
 *      *-L* {{{<ip>}}}     Local IP address (optional).
 *      *-m* {{{<number>}}}     Number of	clients	(default is 1, 2 or 4,	depending  on  options below).
 *      *-e* {{{<ip>}}}     Peer address.
 *      *-r* {{{<port>}}}     Peer port	(default 3480).
 *	*-z* {{{<number>}}}     Per-session packet interval in milliseconds (default is 20 ms).
 *	*-u* {{{<user>}}}     STUN/TURN username.
 *	*-w* {{{<password>}}}     STUN/TURN user password.
 *	*-W* {{{<secret>}}}     TURN REST API secret. Is not compatible with -A flag.
 *	*-C* {{{<symbol>}}}     This is the username/timestamp separator symbol (character) in TURN REST API. The default value is ':'.

       See the _turnutils_uclient_ usage examples	in the "examples/scripts" directory.

=== turnutils_peer  application (for test purposes ony) ===
turnutils_peer is a simple UDP-only echo backend server. This application is used for the test purposes only, as a '_peer_'  for the _turnutils_uclient_ application.

====Usage:====
{{{
       $ turnutils_peer [-v] [options]
}}}
====Options:====

 *      *-p* {{{<port>}}}     Listening	UDP port (Default: 3480).
 *      *-d* {{{<device-name>}}}     Listening	interface device (optional, Linux only)
 *      *-L* {{{<ip>}}}     Listening	address	of _turnutils_peer_	server. Multiple listening addresses can be used, IPv4 and IPv6. If no listener address(es) defined, then it listens on all IPv4 and IPv6 addresses.
 *      *-v*     Verbose

=== turnutils_stunclient is a basic STUN client ===
It sends a STUN request and shows the reply information.

====Usage:====
{{{
       $ turnutils_stunclient [options] <STUN-Server-IP-address>
}}}
====Options:====

 *      *-p* {{{<port>}}}     STUN server port (Default: 3478).
 *      *-L* {{{<ip>}}}     Local address to use (optional).

=== turnutils_rfc5769check tests the correctness of STUN protocol ===
It tests the protocol implementation against the test vectors predefined in RFC 5769 and prints the results of the tests on the screen.   
  
====Usage:====  
{{{
$ turnutils_rfc5769check
}}}

== LIBRARIES ==

       In the lib/ sub-directory the build process  will  create  TURN	client
       messaging  library.   In	 the  include/	sub-directory,	the  necessary
       include files will be placed. 
       The C++ wrapper for the messaging functionality is located in TurnMsgLib.h header.
       An example of C++ code can be found in stunclient.c file.

== DOCS ==

In the original archive tree, the command:

	$ man -M man turnserver

will give you the man page.

After the proper installation, the command:

	$ man turnserver
	
will give you the same man page.

In the docs/html subdirectory of the original archive tree, you will find the client library 
reference. After the installation, it will be placed in 
PREFIX/share/doc/turnserver/html.
 
== LOGS ==

When the *TURN Server* starts, it makes efforts to create a log file {{{turnserver_<pid>.log}}} 
in the following directories:

	* /var/log
	* /log/
	* /var/tmp
	* /tmp
	* current directory

If all efforts failed (due to the system permission settings) then all 
log messages are sent only to the standard output of the process.

This behavior can be controlled by --log-file and --no-stdout-log options (see turnserver help).

== CLUSTERS ==

TURN Server can be a part of the cluster installation. But, to support the "even port" functionality 
(RTP/RTCP streams pairs) the client requests from a particular IP must be delivered to the same 
TURN Server instance, so it requires some networking setup massaging for the cluster. The reason is that 
the RTP and RTCP relaying endpoints must be allocated on the same relay IP. It would be possible 
to design a scheme with the application-level requests forwarding (and we may do that later) but 
it would affect the performance.

== Performance tuning ==

The TURN Server performance depends on how efficiently the operational system
handles the TCP/IP stack. Usually, the TCP part of it is properly optimized, 
but the UDP handling is often suboptimal - so far, a typical UDP stack 
implementation is not very well tuned for the "persistent" UDP sessions like 
ones used in TURN. For example, by default the Linux kernel hashes all UDP 
sockets in just 128 buckets; if you have thousands UDP sessions then you have 
lots of UDP sockets which are handled inefficiently. 

In other words, the implementation of UDP in the Linux kernel makes use a 
hash table to store socket structures. In kernel 2.6.32 (default in CentOS 6,
for example) this hash table is hardcoded to have 128 entries. So with a
large number of sockets, the performance of the table degrades to a linked
list which must be traversed for each incoming packet. 

If you have a Linux kernel <=2.6.32 then you can change the hardcoded hash 
size in the kernel code and re-compile the kernel. If you have a more recent
kernel then you can do that without kernel recompilation. Kernel 2.6.33 
introduced a configurable UDP hash table size, and a second UDP hash table,
keyed by IP+port (previous to this it was only by port). You can configure
the hash table size by setting the "uhash_entries" boot-time kernel variable
(for example, in /etc/grub.conf). For best performance, set it to 65536.
 
Other OSs have similar issues. Check documentation to your OS for 
configuration instructions.

The TURN Server is designed as a multi-threaded network packets routing 
system. But multi-threading is not always the best option for a particular
system configuration. The default start-up TURN Server configuration is a
compromise between memory, thread affinity, cache and CPU resources, and
between TCP and UDP typical "vanilla" OS networking stack implementations.
This is not a specialised system tuned for a very particular hardware, 
a particular OS or a particular load pattern. The TURN Server design is 
tuned for very wide range of possible applications, so it may not be 
100% most optimal for a particular application. But it must be good enough
to be usable everywhere. 
  
The TURN server parameter -m allows tuning of the threading configuration. 
You can turn off the multi-threading by using "-m 0" parameter 
(or "--relay-threads=0"). It will keep all network packets processing within
one thread, eliminating context switch etc - it may be a more efficient 
option for your system. There still will be a separate authentication thread
because the authentication process must not be holding the normalpackets 
routing.

You can use "-m 0" option and run multiple TURN servers on your system, one 
per CPU core. That would be probably the best performance option in terms of 
scalability. Each TURN server must have its own network listening address and
its own relay IP and/or relay ports range - so the configuration will be
complicated - but the performance will be the best possible. You can use 
ALTERNATE-SERVER mechanism to present the whole "pack" as a single "initial"
TURN server front-end to the external world.

== FILES ==

/etc/turnserver.conf

/etc/turnuserdb.conf

/usr/local/etc/turnserver.conf

/usr/local/etc/turnuserdb.conf

== STANDARDS ==

classic STUN RFC 3489

new STUN RFC 5389

TURN RFC 5766

TURN-TCP extension RFC 6062
 
TURN IPv6 extension RFC 6156

STUN/TURN test vectors RFC 5769

STUN NAT behavior discovery RFC 5780

== WEB RESOURCES ==

project page: http://code.google.com/p/rfc5766-turn-server/

forum: https://groups.google.com/forum/?fromgroups=#!forum/turn-server-project-rfc5766-turn-server/

== AUTHORS ==

Oleg Moskalenko <mom040267@gmail.com>
	design, coding

Gabor Kovesdan, http://kovesdan.org :
	FreeBSD packaging
	(since v1.5.2.6);
	
Daniel Pocock, http://danielpocock.com :
	Debian packaging
	(since v1.8.3.6);
	
John Selbie (jselbie) :
	Stuntman interoperability, RFC5780 fixes 
	(since v1.8.3.6);
	
Lee Sylvester <lee@designrealm.co.uk> :
	Status and statistics - ideas and pilot implementation
	(since v1.8.4.0);

Erik Johnston <erikj@openmarket.com> :
	Access Control Lists, 2013 
	(since v1.8.5.0);

Roman Lisagor <roman@demonware.net> :
	Testing, code optimization
	(since v1.8.6.0);

Vladimir Tsanev <tsachev@gmail.com> :
	configure script and Makefile fixes,
	Arch Linux port
	(since v1.8.6.1);
						TURN(08 Aug 2013)